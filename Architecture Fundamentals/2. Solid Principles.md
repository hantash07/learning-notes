The **SOLID principles** are **5 core object-oriented design principles** that make your code **cleaner, flexible, testable, and maintainable**.

The following are the solid principles:
### 1. Single Responsibility Principle (SRP)
- A class or function should have one purpose.
- A class should have one reason to change.

**Bad Example**
- UI logic + database + networking mixed
- Hard to test
	```
	class NotesViewModel {
	    fun getNotes() {}
	    fun saveNoteToDb() {}
	    fun syncNotesWithServer() {}
	}
	```

**Good Example**
- Each class has **one responsibility**
- Easy to test and modify
	```
	class NotesViewModel(
	    private val getNotesUseCase: GetNotesUseCase
	)
	
	class SaveNoteUseCase
	
	class SyncNotesUseCase
	```

**Android Tip**
- ViewModel → UI logic only
- UseCase → Business logic
- Repository → Data handling

****
### 2. Open/Closed Principle (OCP)
- A class should be open for extension and closed for modification.
- You should add new behaviour without changing the existing code.

**Bad Example**
- Whenever a new type is added, the function is modified.
	```
	fun sync(type: String) {
	    if (type == "MANUAL") {}
	    else if (type == "AUTO") {}
	}
	```

**Good Example**
- By adding a new type, the existing code remains unchanged.
	```
	interface SyncStrategy {
	    fun sync()
	}
	
	class ManualSync : SyncStrategy {
	    override fun sync() {}
	}
	
	class AutoSync : SyncStrategy {
	    override fun sync() {}
	}
	```

**Android Tip**
- Use **sealed classes/interfaces** for extensibility.
****

### 3. Liskov Substitution Principle (LSP)
- Subclasses should not implement functions from the superclass that are not required.

**LSP Violation Example**
- The following example violates LSP, as Penguin cannot truly substitute `Bird`.
- Code expecting `Bird.fly()` will crash
	```
	open class Bird {
	    open fun fly() {
	        println("Flying")
	    }
	}
	
	class Penguin : Bird() {
	    override fun fly() {
	        throw UnsupportedOperationException("Penguins can't fly")
	    }
	}
	```

**LSP Good Example**
- The following example does not force **`Penguin`** to implement **`fly()`**
- No unexpected behavior
	```
	interface Bird
	
	interface FlyingBird : Bird {
	    fun fly()
	}
	
	class Sparrow : FlyingBird {
	    override fun fly() {
	        println("Flying")
	    }
	}
	
	class Penguin : Bird
	```

**Android Tip**
- Prefer **interfaces over inheritance**
****

### 4. Interface Segregation Principle
- A class should not be forced to implement all the methods of an interface.
- A class should only implement the methods it requires.
- Large, fat interfaces are bad.
- Small, focused interfaces are good.

#### Problem Without ISP
**Fat Interface Example**
```
interface Printer {
    fun print()
    fun scan()
    fun fax()
}
```

**Simple printer forced to implement scan/fax:**
```
class SimplePrinter : Printer {
    override fun print() { }
    override fun scan() { throw Exception("Not supported") }
    override fun fax() { throw Exception("Not supported") }
}
```

**Issues Here**
- The robot is **forced** to implement methods it doesn’t need
- Violates ISP
- Leads to **runtime errors**

#### Solution Using ISP (Good Design)
**Split the interface into smaller ones:**
```
interface Printable {
    fun print()
}

interface Scannable {
    fun scan()
}

interface Faxable {
    fun fax()
}
```

**Now implement only what’s needed:**
```
class SimplePrinter : Printable {
    override fun print() { }
}

class AllInOnePrinter : Printable, Scannable, Faxable {
    override fun print() { }
    override fun scan() { }
    override fun fax() { }
}
```

****

### 5. Dependency Inversion Principle (DIP)
- High-level modules should not depend on low-level modules. Both should depend on abstractions.
- In simple words, Business logic should not depend on concrete implementations. They should depend on **interfaces**
- A class should depend on an abstract class, not on a concrete class.
- Abstraction should not depend on details. Details or implementations should depend on abstraction.

**Without DIP**
```
ViewModel → RepositoryImpl → Retrofit
```
- ViewModel directly depends on the implementation
- Hard to test
- Hard to change implementation

**With DIP (Good Design)**
```
ViewModel → Repository (Interface)
RepositoryImpl → Repository
```

**Kotlin Example**
Abstraction
```
interface NoteRepository {
    suspend fun getNotes(): List<Note>
}
```

Low-level implementation
```
class NoteRepositoryImpl(
    private val api: NoteApi,
    private val dao: NoteDao
) : NoteRepository {

    override suspend fun getNotes(): List<Note> {
        return dao.getNotes()
    }
}
```

High-level module
```
class NoteViewModel(
    private val repository: NoteRepository
) : ViewModel() {

    fun loadNotes() = repository.getNotes()
}

```

**Summary**
- DIP ensures that business logic is independent of frameworks and implementations by relying on abstractions.
- It's a common mistake to depend on `RepositoryImpl` instead of the interface, putting interfaces in the data layer, and using DI, but still depending on concrete classes

****

**Short Cut to remember the 5 solid principles**
- First, talk about class creation
- Then, how to modify an existing class
- Inheritance, the class should implement function that are required from the superclass
- Interface, instead of a big interface, make it small or chunks
- Dependency: A class should depend on an abstraction, not on a concrete class.

****