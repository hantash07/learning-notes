- It is the container of code that fulfils one purpose.
- Every dependency or library you include in your project is a module.
- The **_app_** folder in your project is also a module that is created by default.
- Each module has its own responsibilities, app gradle, build configuration, and dependencies.
- It can be built and tested independently.

**In Android/Kotlin Projects**
A module can be:
- A feature (e.g., login, home, profile)
- A layer (e.g., data, domain, ui)
- A shared Utility (e.g., core, network, database)

**Multi Modules**
- A project is divided into multiple modules instead of a single large module.
- Each module is a separate, independent part of the project with its own responsibilities.
- Multi-Modules is not for a solo developer, a small project, or a project with tight deadlines

****
### Modularization Strategies
#### 1. Layer-Based Modularization
- Modules are created based on layers
- Faster Gradle build.
- Good for separation
- Not scalable for very large apps.
- Not good for reusability.
- Not good for team working on a single layer.
	```
	:app
	:domain
	:data
	:core
	:common
	```

#### 2. Feature-Based Modularization
- Modules are created based on the features.
- Very scalable
- Features are independent
- can be developed, tested, and released separately.
- Suitable for large apps
- Requires good planning
	```
	:feature:login
	:feature:home
	:feature:profile
	:core:ui
	:core:data
	```

#### 3. **Hybrid Modularization**
- It is the combination of both layer-based and feature-based modules
- Most flexible
- Reusable core components
	```
	:app
	:feature:match
	:feature:scoreboard
	:feature:settings
	:core:ui
	:core:network
	:core:database
	:core:designsystem
	```

****
### Why Use Multi-Modules?
- Faster build time. Gradle build only runs on the updated module.
- Better code organization.
- Core modules can be used across features.
- Different developers can work on different modules without conflicts.
- A bug in one module won't affect the other modules.

****
### Disadvantages of Multi-Modules?
- It takes time on initial setup.
- Gradle configuration is hard to manage.
- Tracing a bug across modules can be tricky.
- Dependency management becomes hard.
- Slower clean builds. While incremental builds are faster, clean builds can be slower due to more modules.

****

### A Package or directory without a Gradle file is not a module.
- If a folder does NOT have its own `build.gradle` / `build.gradle.kts`, it is NOT a module.
- It is just a **package (directory)** inside another module.
- A directory without a Gradle file is just a code organization.

****

#### What is Component?
- A component is a logical or runtime part of the system that performs a specific responsibility.
- It lives inside modules
- A module is a Gradle build unit that enforces compile-time boundaries, while a component is a logical or runtime unit that encapsulates a specific responsibility within or across modules. Modules structure the build; components structure the behavior.
- Examples: ViewModel, Repository, UseCase, DataSource, Hilt/Dagger Component.

****