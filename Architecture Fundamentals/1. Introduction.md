- It refers to the core principles and components that the developers should follow when structuring an Android App.
- By following the core principles, the app will become scalable, testable, maintainable, and easy to evolve.

### Below is a clean breakdown of the essential fundamentals:
#### 1. Separation of concerns (SOC)
Each part of your app should have **one clear job**, not multiple.
- **UI layer** → Displays data and reacts to user input.
- **Data layer** → Fetches/saves data (Room, network, preferences).
- **Domain layer** → Holds business logic (use cases).

#### 2. Unidirectional Data Flow (UDF)
- Data flows **in one direction only**, making the state predictable.
```
UI → ViewModel → Use Case → Repository → Data Source
                       ↑---------------------------|
```
- UI sends events downward; data flows back upward as state.
- Compose especially benefits from UDF.

#### 3. Use of Architecture Components
Google recommends Android Jetpack components:
- **ViewModel**
	- Survives configuration changes
	- Holds UI state
	- Communicates with repositories
	- Exposes Flows / LiveData
- **Room**
	- Local DB abstraction
	- Works well with coroutines/Flow
- **WorkManager**
	- Background tasks (syncing, uploading, periodic tasks)
- **Navigation**
	- Single-activity apps
	- Handles back stack cleanly

#### 4. MVVM Architecture
The most common architecture in Android.
```
UI (Compose/Fragments)
      |
ViewModel
      |
Repository
      |
Local DB (Room) + Network (Retrofit)
```

#### 5. Use Coroutines & Flow for Asynchronous Work
- Coroutines for background tasks
- Flow/StateFlow for real-time UI updates
- Handles lifecycle automatically using `viewModelScope`

#### 6. Repositories as the Single Source of Truth (SSOT)
The repository decides where the data comes from:
```
Repository {
   local = Room
   remote = Retrofit
   sync = handled internally
}
```

#### 7. Dependency Injection (DI)
It handles dependencies between classes efficiently.
Common DI tools:
- Hilt
- Koin
- Dagger2

#### 8. Modularity
As apps grow, split them into modules:
- `app` (UI)
- `core` (shared utilities)
- feature-xxx
- data
- domain
Benefits:
- Faster builds
- Easier testing
- Team scalability

#### 9. Offline-First Architecture
- Make some part of your app support local.
- Example: Show the last browsed products, when the user tries to check out, ask for a network connection.
**Core idea:**
- Room = primary source of truth
- Network = updates Room
- UI = observes Room via Flow

#### 10. Clean Architecture
Create three different layers for each feature.
```
Presentation  → UI + ViewModel
Domain        → Use Cases + Entities
Data          → Repository + Data sources
```

