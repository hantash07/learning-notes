Clean Architecture separates your app into layers with strict dependency rules.
- Inner layers should never depend on outer layers.
- Business logic should not depend on frameworks (Android SDK, Retrofit, Room, etc.).

The 3 Goals of Clean Architecture:
- Scalability - How easy is it to add new features?
- Readability - How easy is it to understand existing code?
- Testability - How easy is it to test the code?

****
### Layers of Clean Architecture
Clean Architecture has three main layers in Android:
#### 1. Domain Layer (The Heart of the App)
- It contains the business logic that will remain the same even if UI, DB, or API changes.
- It describes what should happen, not how it should happen.
- It contains pure Kotlin. No Android Framework.
- This layer makes it easy for other developers to understand what the app does and what problem it solves.
- Less likely to change lives inside the domain layer.
	```
	interface NotesRepository {
	    fun getNotes(): Flow<List<Note>>
	    suspend fun addNote(note: Note)
	    suspend fun syncNotes()
	}
	```
- ##### Why is the domain the innermost layer?
	- This layer requires fewer changes.
	- Frequently changing parts should not require changes in the less frequently changing parts of the app.
	- Implementation details usually change more often than core application logic.
- ##### Models:
	- Models encapsulate the most fundamental business rules of the app
	- Among the least likely parts to change
	- Very reusable
- ##### Gateway / Repository Abstraction
	- Gateways are an abstraction that hides implementation details.
	- Repositories are commonly used on Android and can be considered a gateway
	- Repository definition lives in the domain.
		```
		package domain.repository
		
		import domain.entity.AuthResult
		
		interface AuthRepository {
		
		    suspend fun login(email: String, password: String): AuthResult
		
		    suspend fun register(name: String, email: String, password: String): AuthResult
		
		    suspend fun logout(): Boolean
		}
		```
- ##### Use Cases
	- Use cases contain pure business logic.
	- Each use case only exposes one public function
	- Highly reusable
	- Class name clearly reveals what's inside
	- Example 1:
		```
		package domain.usecase
		
		import domain.repository.AuthRepository
		
		class LoginUseCase(
		    private val authRepository: AuthRepository
		) {
		    suspend operator fun invoke(email: String, password: String) =
		        authRepository.login(email, password)
		}
		```
	- Example 2:
		```
		class CalculateDiscountUseCase(
		    private val repository: ProductRepository
		) {
		    suspend operator fun invoke(productId: String): DiscountResult {
		        val product = repository.getProductById(productId)
		
		        val discountAmount = product.price * (product.discountPercent / 100)
		        val finalPrice = product.price - discountAmount
		
		        return DiscountResult(
		            originalPrice = product.price,
		            discountPercent = product.discountPercent,
		            discountAmount = discountAmount,
		            finalPrice = finalPrice
		        )
		    }
		}
		
		data class DiscountResult(
		    val originalPrice: Double,
		    val discountPercent: Double,
		    val discountAmount: Double,
		    val finalPrice: Double
		)
		```

#### 2. Data Layer (Implementation Layer)
- It describes how things happen.
- This layer implements the interfaces defined in the Domain layer.
- The data layer is the bridge to external data sources.
- Common data sources include local databases, remote APIs, or the file system. Data sources can be of different natures, like GPS Provider, Sensors, Bluetooth, etc.
- It has communication outside the world. Outside the world means not part of your app, for example, Remote API, Database, etc.
- It can contain the Android Framework.
- Decide where data comes from (DB, network, cache, etc.)
- When Implementation details change, only the data layer needs to change. This is possible because of the Domain layer.
	```
	package data.repository
	
	import data.mapper.toDomain
	import data.remote.AuthApi
	import data.remote.model.LoginRequestDto
	import data.remote.model.RegisterRequestDto
	import domain.entity.AuthResult
	import domain.entity.User
	import domain.repository.AuthRepository
	
	class AuthRepositoryImpl(
	    private val api: AuthApi
	) : AuthRepository {
	
	    override suspend fun login(email: String, password: String): AuthResult {
	        /// Implementation here
	    }
	
	    override suspend fun register(name: String, email: String, password: String): AuthResult {
	         /// Implementation here
	    }
	
	    override suspend fun logout(): Boolean {
	         /// Implementation here
	    }
	}
	```

- ##### Data Models - DTOs
	- DTO = Data Transfer Object
	- Most likely the direct result of a JSON object
		```
		package data.remote.model
		
		data class UserDto(
		    val id: String,
		    val name: String,
		    val email: String
		)
		```

- ##### Data Models - DB Entities
	- These data models are used for data storage for the local database
		```
		package data.remote.model
		
		@Entity
		data class User(
			@PrimaryKey
		    val id: String,
		    val name: String,
		    val email: String
		)
		```

- ##### Mappers
	- Its main purpose is to convert external data or raw data into clean domain models.
	- It converts the data layer models (DTOs, Entities) into Domain Layer models.
	- With the help of mappers, it makes the domain layer not depend on the data layer. The domain layer cannot import DTOs of data layer. Whereas the Data layer can import models of the domain layer.
	- It fulfils the defined dependency between the domain and data layer.
		```
		fun UserDto.toDomain() = User(
		    id = user_id,
		    name = full_name,
		    email = email_address
		)
		```

#### 3. Presentation Layer (UI Layer)
- This is the part of the app the user sees. 
- It contains UI code, ViewModel, Navigation logic, and state management.
- It only interacts with the **Domain Layer** through **Use Cases**
- Does not know anything about the **Data Layer** (repositories, Room, Retrofit, etc.)
- It is a misconception that MVVM is applied to the whole app. Instead, it only applies to this layer.
- Responsibilities: 
	- Show data to the user
	- Listen to user action
	- Validate input
	- Send UI events to ViewModel
	- Observe state
	- Should contain zero business logic
```
class NotesViewModel(
    private val getNotes: GetNotesUseCase,
    private val addNote: AddNoteUseCase
) : ViewModel() {

    val notes = getNotes().stateIn(...)
    
    fun onAddClicked(note: Note) {
        addNote(note)
    }
}
```

****
### Difference between Domain Layer and Data Layer
- The Domain Layer outlines what the app is capable of doing. For example, my app has a login and registration function
- The Data Layer outlines the implementation details of the Domain layer. For example, how login and registration work. What kind of network library is your app using?
- Domain layer outlines the problems. The Data layers provide the solutions to the problems.

****
### Dependencies between Layers
- Presentation and data layers are allowed to have dependencies on the domain layer.
- The domain layer is isolated. It doesn't have a dependency on either the presentation layer or the data layer.
- The domain layer does not know the implementation of the presentation layer or the data layer.
- Presentation layer can't have dependencies on the data layer or vice versa.

****
### How Data Flows in Clean Architecture
#### UI → ViewModel → Use Case → Repository → Data Sources → Repository → Use Case → ViewModel → UI

**Example:**
User clicks “Add Note”
```
Presentation Layer:
Compose → ViewModel → AddNoteUseCase
```

AddNoteUseCase
```
Domain Layer:
AddNoteUseCase → NotesRepository
```

Repository Implementation
```
Data Layer:
NotesRepositoryImpl → Room + Retrofit + Sync Logic
```

Data returns
```
Data Layer → Repository → UseCase → ViewModel → UI
```

****
### Why Clean Architecture is powerful
- ##### Scalability:
	- Changes in the data or presentation layer won't affect the core of the app
	- Clear rules on where to add new features and easy-to-find components.
	- Easy to make changes. If there are changes related to the network api or local database, only the data layer is changed.
- ##### Testability:
	- Logic is isolated to allow easy testing
	- Predictable data flow
- ##### Readability:
	- Easy for other developers to understand the core features of the app by only reviewing the Domain layer.

****
### Where do Android components or platform-specific components go in Clean Architecture?
- In clean architecture, there are two options to put Android components like WorkManager, Foreground Services, Job schedulers, Notifications, Permissions handling, Navigation, compose UI, Location tracking, BroadcastReceivers, or ViewModels, etc. The following are the options:
	- Presentation Layer
	- Platform Layer
- Domain and Data layers should not know about platform-specific components
-  Presentation Layer is the preferred place to put platform-specific components, as the Platform Layer requires creating a new layer. By creating another new layer, the architecture becomes more complex.

****
### Why Android components must stay in the Framework/Platform Layer?
- They depend on the Android SDK. Domain and Data must remain **pure Kotlin**, testable, and platform-agnostic.
- They are lifecycle-aware. WorkManager, Service, and Location APIs require context or an Android environment.
- They interact with the OS. 

****