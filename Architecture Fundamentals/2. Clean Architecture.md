
Clean Architecture separates your app into layers with strict dependency rules.
- Inner layers should never depend on outer layers.
- Business logic should not depend on frameworks (Android SDK, Retrofit, Room, etc.).

### Layers of Clean Architecture
Clean Architecture has three main layers in Android:
#### 1. Presentation Layer (UI Layer)
- This is the part of the app the user sees. 
- It contains UI code, ViewModel, and state handling or state management.
- It only interacts with the **Domain Layer** through **Use Cases**
- Does not know anything about the **Data Layer** (repositories, Room, Retrofit, etc.)
- It is a misconception that MVVM is applied to the whole app. Instead, it only applies to this layer.
- Responsibilities: 
	- Show data to the user
	- Listen to user action
	- Validate input
	- Send UI events to ViewModel
	- Observe state
	- Should contain zero business logic
```
class NotesViewModel(
    private val getNotes: GetNotesUseCase,
    private val addNote: AddNoteUseCase
) : ViewModel() {

    val notes = getNotes().stateIn(...)
    
    fun onAddClicked(note: Note) {
        addNote(note)
    }
}
```

#### 2. Domain Layer (The Heart of the App)
- It contains the business logic that will remain the same even if UI, DB, or API changes.
- It describes what should happen, not how it should happen.
- It contains pure Kotlin. No Android Framework.
```
interface NotesRepository {
    fun getNotes(): Flow<List<Note>>
    suspend fun addNote(note: Note)
    suspend fun syncNotes()
}
```


#### 3. Data Layer (Implementation Layer)
- It describes how things happen.
- This layer implements the interfaces defined in the Domain layer.
- It has communication outside the world. Outside the world means not part of your app, for example, Remote API, Database, etc.
- It can contain the Android Framework.
- Decide _where_ data comes from (DB, network, cache, etc.)
- Mappers (convert data models → domain models)

### Difference between Domain Layer and Data Layer
- The Domain Layer outlines what the app is capable of doing. For example, my app has a login and registration function
- The Data Layer outlines the implementation details of the Domain layer. For example, how login and registration work. What kind of network library is your app using?

### Dependencies between Layers
- Presentation and data layers are allowed to have dependencies on the domain layer.
- The domain layer is isolated. It doesn't have a dependency on either the presentation layer or the data layer.
- The domain layer does not know the implementation of the presentation layer or the data layer.
- Presentation layer can't have dependencies on the data layer or vice versa.

### How Data Flows in Clean Architecture
#### UI → ViewModel → Use Case → Repository → Data Sources → Repository → Use Case → ViewModel → UI

**Example:**
User clicks “Add Note”
```
Presentation Layer:
Compose → ViewModel → AddNoteUseCase
```

AddNoteUseCase
```
Domain Layer:
AddNoteUseCase → NotesRepository
```

Repository Implementation
```
Data Layer:
NotesRepositoryImpl → Room + Retrofit + Sync Logic
```

Data returns
```
Data Layer → Repository → UseCase → ViewModel → UI
```

### Why Clean Architecture is powerful
- Easy to test
- Easy to make changes. If there are changes related to the network api or local database, only the data layer is changed.
- Promote scalability. If new features come in, no need to make a lot of changes. 
