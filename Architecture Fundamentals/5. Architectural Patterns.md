The following are the 4 most used architectural patterns in Android:

### 1. MVC - Model View Controller
**MVC divides the apps into three components:**
- ***Model ->*** Business data & logic
- ***View ->*** UI, Activities & Fragments
- ***Controller ->*** Middleman between Model and View

##### Flow (Step-by-Step)
- User interacts with the view.
- View notifies the controller
- Controller updates or fetches data from the Model
- Controller sends updated data back to the View
- View renders the UI
```
User → View → Controller → Model
                 ↓
               View
```

##### Advantages of MVC
- Easy to understand
- Faster development for small apps

##### Disadvantages of MVC
- Tight coupling or connection between View and Controller
- Difficult to test UI logic
- Not ideal for large-scale Android apps
- 
##### Example
Note: In Android, **Activities/Fragments often act as both View and Controller**, which breaks pure MVC.
```
class LoginActivity : AppCompatActivity() {

    fun onLoginClick() {
        val isValid = UserModel().login(username, password)
        if (isValid) {
            showHome()
        }
    }
}
```

****

### 2. MVP -  Model View Presenter
- MVP separates the UI logic into a presenter
- It enhances testability and reduces the tight coupling between the UI and logic.
- **View ->** Only UI
- **Presenter ->** Business logic & UI decisions
- **Model ->** Data layer or Data Sources

***Unlike MVC, the View does not talk directly to the Model.  All communication goes through the Presenter.***

##### Flow (Step-by-Step)
- User interacts with the view.
- View notifies the presenter's interfaces
- Presenter updates or fetches data from the Model
- The presenter sends updated data back to the View using interfaces
- View renders the UI
```
User Action
   ↓
View (Activity / Fragment)
   ↓
Presenter
   ↓
Model (Repository / Data Source)
   ↓
Presenter
   ↓
View
```

***The View never directly touches the Model***

##### Advantages
- Easier to maintain than MVC
- Clear separation of concerns 
- Highly testable

##### Disadvantages
- More interfaces > More boilerplate of code
- Manual lifecycle handling
- Not lifecycle-aware

##### Example
**View Interface**
```
interface LoginView {
    fun showSuccess()
    fun showError()
}
```

**Presenter**
```
class LoginPresenter(private val view: LoginView) {

    fun login(username: String, password: String) {
        if (username == "admin") {
            view.showSuccess()
        } else {
            view.showError()
        }
    }
}
```

**Activity**
```
class LoginActivity : AppCompatActivity(), LoginView {

    private val presenter = LoginPresenter(this)

    fun onLoginClick() {
        presenter.login("admin", "123")
    }
}
```

****

### 3. MVVM - Model View ViewModel
- MVVM introduces ViewModel, which exposes observable state.
- With MVVM, we can do reactive programming.
- It introduces observable states.
- When observable states change, the UI automatically renders.
- It focuses on separation of concerns, testability, and UI state management
- It supports two-way binding
- MVVM is not unidirectional by default, but we can make MVVM support unidirectional data flow 

##### MVVM Components
**Model**
- The **Model** represents the **business logic and data layer**.
- Business rules
- Data sources (API, database, cache)
- Repositories

**View**
- Display UI
- Observe the state from the ViewModel
- Forward user actions to the ViewModel

**ViewModel**
- The **ViewModel** is the **heart of MVVM**.
- Hold UI state
- Transform Model data into UI-friendly format
- Handle user actions
- Expose observable data to the View
- Survive configuration changes (Android)

**ViewModel **never references the View****

##### Flow (Step-by-Step)
- View observes ViewModel
- ViewModel updates state
- No direct View ↔ Model communication
```
User Action
   ↓
View
   ↓
ViewModel
   ↓
Model (Repository / UseCase)
   ↓
ViewModel (State Update)
   ↓
View (UI Update)
```

##### Advantages
- Lifecycle-aware
- Works perfectly with reactive programming (Flow, Rx, LiveData)
- Clear separation of concerns
- Highly testable (ViewModel unit testing)

##### Disadvantages
- Can become **over-engineered** for small apps
- Requires good state management discipline

##### Example
**ViewModel**
```
class LoginViewModel : ViewModel() {

    private val _state = MutableStateFlow(false)
    val state: StateFlow<Boolean> = _state

    fun login(username: String) {
        _state.value = username == "admin"
    }
}
```

View (Compose)
```
@Composable
fun LoginScreen(vm: LoginViewModel) {
    val isSuccess by vm.state.collectAsState()

    if (isSuccess) {
        Text("Login Success")
    }
}
```

****

### 4. MVI - Model View Intent (Unidirectional Data Flow)
- MVI is a **unidirectional architecture pattern** mainly used for **state-driven UIs**, especially in **Android (Jetpack Compose)**.
- MVI is preferably used for declarative UI.
- Data flows in one direction only.
- ViewModel still exists in MVI.
- In MVI, it encapsulates all the states, actions, and events in a separate class and makes them immutable members of the class. 
- Whenever there is a change in state, a new instance of the class is returned.
	```
	User Action → Intent → Reducer → New State → View
	```

##### Core Components of MVI
**View**
- UI layer (Activity / Fragment / Composable)
- Observes state
- Sends user actions as Intents
- Never contains business logic
```
@Composable
fun LoginScreen(
    state: LoginState,
    onIntent: (LoginIntent) -> Unit
) {
    Button(onClick = { onIntent(LoginIntent.LoginClicked) }) {
        Text("Login")
    }
}
```

**Intent**
- Represents **user actions or events**
- Immutable
- Describes **what happened**, not how to handle it
```
sealed class LoginScreemAction {
    object LoginClicked : LoginIntent()
    data class EmailChanged(val value: String) : LoginIntent()
}
```

**Model**
- The model is the same as the model in the MVVM pattern.

**Reducer (Core of MVI)**
- A pure function that takes (oldState + Intent) and returns newState
- Must not call APIs directly
- It is implicitly done. No need for an explicit function or a file.
- Reducer is often merged into the ViewModel
	- Most Android teams do this:
		```
		private fun setLoading() {
		    _state.update { it.copy(isLoading = true) }
		}
		
		private fun setSuccess(data: Data) {
		    _state.update { it.copy(isLoading = false, data = data) }
		}
		```
	- These functions **ARE reducers**
	- Just not in a separate file

**Example - Implicitly**
You are already reducing state, just _inline_.
```
_state.value = _state.value.copy(isLoading = true)
```

**Example - Explicitly**
```
fun reduce(
    state: LoginState,
    intent: LoginIntent
): LoginState {
    return when (intent) {
        is LoginIntent.EmailChanged ->
            state.copy(email = intent.value)

        LoginIntent.LoginClicked ->
            state.copy(isLoading = true)
    }
}
```

**ViewModel (Or Store)**
- It manages the states and intents
```
class LoginViewModel : ViewModel() {

    private val _state = MutableStateFlow(LoginState())
    val state: StateFlow<LoginState> = _state

    fun processIntent(intent: LoginIntent) {
        _state.value = reduce(_state.value, intent)

        when (intent) {
            LoginIntent.LoginClicked -> login()
            else -> Unit
        }
    }

    private fun login() {
        // API call
    }
}
```

##### Data Flow
```
┌────────┐
│  View  │
└───┬────┘
    │ Intent
    ▼
┌─────────────┐
│ ViewModel   │
│ / Store     │
└───┬─────────┘
    │ Reduce
    ▼
┌─────────────┐
│  State      │
└───┬─────────┘
    │ Observe
    ▼
┌────────┐
│  View  │
└────────┘
```

##### Advantages
- Predictable state
- Easy debugging
- No inconsistent UI states
- Perfect for Compose
- Easy testing

##### Disadvantages
- More boilerplate
- Large state objects
- Overkill for simple screens

##### Example
**Intent (User Actions)**
```
sealed interface LoginIntent {
    data class Submit(val username: String) : LoginIntent
}
```

**UI State (Single source of truth)**
```
data class LoginUiState(
    val isLoading: Boolean = false,
    val isSuccess: Boolean = false,
    val error: String? = null
)
```

**ViewModel**
```
class LoginViewModel : ViewModel() {

    private val _state = MutableStateFlow(LoginUiState())
    val state: StateFlow<LoginUiState> = _state

    fun onIntent(intent: LoginIntent) {
        when (intent) {
            is LoginIntent.Submit -> login(intent.username)
        }
    }

    private fun login(username: String) {
        _state.value = _state.value.copy(isLoading = true)

        viewModelScope.launch {
            delay(1000) // simulate API call

            if (username == "admin") {
                _state.value = LoginUiState(isSuccess = true)
            } else {
                _state.value = LoginUiState(error = "Invalid username")
            }
        }
    }
}
```

**View**
```
@Composable
fun LoginScreen(vm: LoginViewModel) {

    val state by vm.state.collectAsState()

    Column {
        Button(
            onClick = {
                vm.onIntent(LoginIntent.Submit("admin"))
            }
        ) {
            Text("Login")
        }

        when {
            state.isLoading -> {
                Text("Loading...")
            }
            state.isSuccess -> {
                Text("Login Success")
            }
            state.error != null -> {
                Text(state.error!!)
            }
        }
    }
}
```

****

#### MVI vs MVVM
| Aspect         | MVVM              | MVI             |
| -------------- | ----------------- | --------------- |
| Data flow      | Two-way possible  | One-way only    |
| State          | Multiple LiveData | Single State    |
| Debugging      | Harder            | Very easy       |
| UI consistency | Medium            | Very high       |
| Boilerplate    | Low               | High            |
| Best for       | XML UI            | Compose / React |


****

### Comparison Table
| Architecture | Best For    | Testability    | Boilerplate | Modern Android |
| ------------ | ----------- | -------------- | ----------- | -------------- |
| MVC          | Small apps  | ❌ Low          | ⭐ Low       | ❌ No           |
| MVP          | Medium apps | ⭐⭐ Good        | ⭐⭐ Medium   | ⚠️ Rare        |
| MVVM         | Most apps   | ⭐⭐⭐ High       | ⭐ Medium    | ✅ Yes          |
| MVI          | Complex UI  | ⭐⭐⭐⭐ Very High | ❌ High      | ✅ Advanced     |
##### Which One Is Better?
**Best Overall (Android): MVVM**
- Officially supported by Google
- Works perfectly with **LiveData / Flow / Compose**
- Easy testing & scalability
**Best for Complex State Apps: MVI**
- Financial apps
- Real-time dashboards
**Avoid MVC in Android**
**MVP only for legacy projects**

##### Conclusion:
For modern Android development, **MVVM is the most balanced and recommended architecture**.  
For applications with complex UI states and unidirectional data flow requirements, **MVI** provides better predictability and debugging capabilities.

****

### Clean Architecture vs Architectural Patterns
- Clean architecture is applied to the whole app, where the app is divided into different layers. 
- Architectural patterns are also known as Presentational Patterns. Architectural patterns are only applied in the Presentation layer it does not applied to the whole app.
- In clean architecture, the Model is the part of the domain layer.
- If there is no domain layer, then the Model will be a part of presentation layer MVVM or MVI.

****