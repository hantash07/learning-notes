The following are the 4 most used architectural patterns in Android:

### 1. MVC - Model View Controller
**MVC divides the apps into three components:**
- ***Model ->*** Business data & logic
- ***View ->*** UI, Activities & Fragments
- ***Controller ->*** Middleman between Model and View

##### Flow (Step-by-Step)
- User interacts with the view.
- View notifies the controller
- Controller updates or fetches data from the Model
- Controller sends updated data back to the View
- View renders the UI
```
User → View → Controller → Model
                 ↓
               View
```

##### Advantages of MVC
- Easy to understand
- Faster development for small apps

##### Disadvantages of MVC
- tight coupling or connection between View and Controller
- Difficult to test UI logic
- Not ideal for large-scale Android apps

##### Example
Note: In Android, **Activities/Fragments often act as both View and Controller**, which breaks pure MVC.
```
class LoginActivity : AppCompatActivity() {

    fun onLoginClick() {
        val isValid = UserModel().login(username, password)
        if (isValid) {
            showHome()
        }
    }
}
```

****

### 2. MVP -  Model View Presenter
- MVP separates the UI logic into a presenter
- It enhances testability and reduces the tight coupling between the UI and logic.
- **View ->** Only UI
- **Presenter ->** Business logic & UI decisions
- **Model ->** Data layer or Data Sources

***Unlike MVC, the View does not talk directly to the Model.  All communication goes through the Presenter.***

##### Flow (Step-by-Step)
- User interacts with the view.
- View notifies the presenter's interfaces
- Presenter updates or fetches data from the Model
- The presenter sends updated data back to the View using interfaces
- View renders the UI
```
User Action
   ↓
View (Activity / Fragment)
   ↓
Presenter
   ↓
Model (Repository / Data Source)
   ↓
Presenter
   ↓
View
```

***The View never directly touches the Model***

##### Advantages
- Easier to maintain than MVC
- Clear separation of concerns 
- Highly testable

##### Disadvantages
- More interfaces > More boilerplate of code
- Manual lifecycle handling
- Not lifecycle-aware

##### Example
**View Interface**
```
interface LoginView {
    fun showSuccess()
    fun showError()
}
```

**Presenter**
```
class LoginPresenter(private val view: LoginView) {

    fun login(username: String, password: String) {
        if (username == "admin") {
            view.showSuccess()
        } else {
            view.showError()
        }
    }
}
```

**Activity**
```
class LoginActivity : AppCompatActivity(), LoginView {

    private val presenter = LoginPresenter(this)

    fun onLoginClick() {
        presenter.login("admin", "123")
    }
}
```

****

### 3. MVVM - Model View ViewModel
- MVVM introduces ViewModel, which exposes observable state.
- It focuses on separation of concerns, testability, and UI state management

##### MVVM Components
**Model**
- The **Model** represents the **business logic and data layer**.
- Business rules
- Data sources (API, database, cache)
- Repositories

**View**
- Display UI
- Observe the state from the ViewModel
- Forward user actions to the ViewModel

**ViewModel**
- The **ViewModel** is the **heart of MVVM**.
- Hold UI state
- Transform Model data into UI-friendly format
- Handle user actions
- Expose observable data to the View
- Survive configuration changes (Android)

**ViewModel **never references the View****

##### Flow (Step-by-Step)
- View observes ViewModel
- ViewModel updates state
- No direct View ↔ Model communication
```
User Action
   ↓
View
   ↓
ViewModel
   ↓
Model (Repository / UseCase)
   ↓
ViewModel (State Update)
   ↓
View (UI Update)
```

##### Advantages
- Lifecycle-aware
- Works perfectly with reactive programming (Flow, Rx, LiveData)
- Clear separation of concerns
- Highly testable (ViewModel unit testing)

##### Disadvantages
- Can become **over-engineered** for small apps
- Requires good state management discipline

##### Example
**ViewModel**
```
class LoginViewModel : ViewModel() {

    private val _state = MutableStateFlow(false)
    val state: StateFlow<Boolean> = _state

    fun login(username: String) {
        _state.value = username == "admin"
    }
}
```

View (Compose)
```
@Composable
fun LoginScreen(vm: LoginViewModel) {
    val isSuccess by vm.state.collectAsState()

    if (isSuccess) {
        Text("Login Success")
    }
}
```

****

### 4. MVI - Model View Intent (Unidirectional Data Flow)
- MVI is a **unidirectional architecture pattern** mainly used for **state-driven UIs**, especially in **Android (Jetpack Compose)**.
- Data flows in one direction only.
	```
	User Action → Intent → Reducer → New State → View
	```

##### Core Components of MVI
**View**
- UI layer (Activity / Fragment / Composable)
- Observes state
- Sends user actions as Intents
- Never contains business logic
```
@Composable
fun LoginScreen(
    state: LoginState,
    onIntent: (LoginIntent) -> Unit
) {
    Button(onClick = { onIntent(LoginIntent.LoginClicked) }) {
        Text("Login")
    }
}
```

**Intent**
- Represents **user actions or events**
- Immutable
- Describes **what happened**, not how to handle it
```
sealed class LoginIntent {
    object LoginClicked : LoginIntent()
    data class EmailChanged(val value: String) : LoginIntent()
}
```

**Model**
- Represents the **entire UI state**
- Single source of truth
```
data class LoginState(
    val email: String = "",
    val isLoading: Boolean = false,
    val error: String? = null
)
```

**Reducer (Core of MVI)**
- A **pure function**
- Takes **current state + intent**
- Returns a **new state**
- Must not call APIs directly
- Must not mutate state
```
fun reduce(
    state: LoginState,
    intent: LoginIntent
): LoginState {
    return when (intent) {
        is LoginIntent.EmailChanged ->
            state.copy(email = intent.value)

        LoginIntent.LoginClicked ->
            state.copy(isLoading = true)
    }
}
```

**ViewModel (Or Store)**
- It manages intent, reducer, and side effects.
```
class LoginViewModel : ViewModel() {

    private val _state = MutableStateFlow(LoginState())
    val state: StateFlow<LoginState> = _state

    fun processIntent(intent: LoginIntent) {
        _state.value = reduce(_state.value, intent)

        when (intent) {
            LoginIntent.LoginClicked -> login()
            else -> Unit
        }
    }

    private fun login() {
        // side effect (API call)
    }
}
```

**Side Effects in MVI**
- It manages the API calls, database, navigation, and toasts.
```
sealed class LoginEffect {
    object NavigateHome : LoginEffect()
    data class ShowError(val message: String) : LoginEffect()
}
```

```
private val _effect = Channel<LoginEffect>()
val effect = _effect.receiveAsFlow()
```

##### Data Flow
```
┌────────┐
│  View  │
└───┬────┘
    │ Intent
    ▼
┌─────────────┐
│ ViewModel   │
│ / Store     │
└───┬─────────┘
    │ Reduce
    ▼
┌─────────────┐
│  State      │
└───┬─────────┘
    │ Observe
    ▼
┌────────┐
│  View  │
└────────┘
```

##### Advantages
- Predictable state
- Easy debugging
- No inconsistent UI states
- Perfect for Compose
- Easy testing

##### Disadvantages
- More boilerplate
- Large state objects
- Overkill for simple screens

##### Example

##### MVI vs MVVM
| Aspect         | MVVM              | MVI             |
| -------------- | ----------------- | --------------- |
| Data flow      | Two-way possible  | One-way only    |
| State          | Multiple LiveData | Single State    |
| Debugging      | Harder            | Very easy       |
| UI consistency | Medium            | Very high       |
| Boilerplate    | Low               | High            |
| Best for       | XML UI            | Compose / React |


****

### Comparison Table
| Architecture | Best For    | Testability    | Boilerplate | Modern Android |
| ------------ | ----------- | -------------- | ----------- | -------------- |
| MVC          | Small apps  | ❌ Low          | ⭐ Low       | ❌ No           |
| MVP          | Medium apps | ⭐⭐ Good        | ⭐⭐ Medium   | ⚠️ Rare        |
| MVVM         | Most apps   | ⭐⭐⭐ High       | ⭐ Medium    | ✅ Yes          |
| MVI          | Complex UI  | ⭐⭐⭐⭐ Very High | ❌ High      | ✅ Advanced     |
##### Which One Is Better?
**Best Overall (Android): MVVM**
- Officially supported by Google
- Works perfectly with **LiveData / Flow / Compose**
- Easy testing & scalability
**Best for Complex State Apps: MVI**
- Financial apps
- Real-time dashboards
**Avoid MVC in Android**
**MVP only for legacy projects**

##### Conclusion:
For modern Android development, **MVVM is the most balanced and recommended architecture**.  
For applications with complex UI states and unidirectional data flow requirements, **MVI** provides better predictability and debugging capabilities.

****