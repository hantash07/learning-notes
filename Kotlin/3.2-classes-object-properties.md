## Properties
- The full syntax for declaring a property is as follows.
  ```
  var <propertyName>[: <PropertyType>] [= <property_initializer>]
    [<getter>]
    [<setter>]
  ```
- The initializer, getter, and setter are optional. The property type can also become an optional if the property is assigned a value or the type can define from its getter.
- The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with val instead of var and does not allow a setter
  ```
  val simple: Int? // has type Int, default getter, must be initialized in constructor
  val inferredType = 1 // has type Int and a default getter
  ```
- You can define a custom controller or accessors for a property. If you define a custom getter, it will be called everytime you access the property. Same case with setter. If you define custom setter, it will be called everytime you assign a value into it.
  Custom Getter:
  ```
  class Rectangle(val width: Int, val height: Int) {
    val area: Int // property type is optional since it can be inferred from the getter's return type
        get() = this.width * this.height
  }
  ```
  
  You can omit the property type if the type can be define from the getter:
  ```
  val area get() = this.width * this.height
  ```

  Custom Setter:
  ```
  var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // parses the string and assigns values to other properties
    }
  ```
    - By convention, the name of the setter parameter is value, but you can choose a different name if you prefer.
  
  - If you want to add annotate and or change the visibility of the property controller, you don't need to change its implementation.
  ```
  var setterVisibility: String = "abc"
    private set // the setter is private and has the default implementation

  var setterWithAnnotation: Any? = null
    @Inject set // annotate the setter with Inject
  ```
#### Backing Field
- In kotlin, backing field is used in order to avoid recursive call on the property which can throw stack overflow exception.
- A `field` is only used as a part of a property to hold its value in memory.
- Kotlin generate backing field, when the property uses its default implementations.
  ```
  class User{
    var firstName : String  //backing field generated 
        get() = firstName
        set(value) {firstName = value}
    
   var lastName : String   //backing field generated
        get() = lastName
        set(value) {lastName = value}
  
   val name : String                         //no backing field generated
        get() = "{$firstName $lastName}"    
   
   var address : String = "XYZ"           //^because there is no default
                                            //implementation of an accessor
                                     
  }
  ```
- In Kotlin, the above code snippet will throw StackOverflow because when we access or set property `firstName` or `lastName` the default accessor will be called. So in Kotlin user.firstName = "value” is same as Java’s user.setFirstName("value").
- So when `set(value) {firstName = "value"}` is called, then a recursive call happens and compiler throws a StackOverflow exception because we are calling setter inside the setter.
- Solution to this problem is to user backing fields. In Kotlin, a backing field can be accessed using 'field' keyword inside accessors.
  ```
  class User{
    var firstName : String  
        get() = field
        set(value) {field = value}
    
   var lastName : String  
        get() = field
        set(value) {field = value}
 
                                     
  }
  ```

#### Backing Properties
- If you don't want to use implicit backinng field, you can use backing properties.
- Backing field is generated by Kotlin, whereas backing properties is generated by user itself.
  ```
  private var _table: Map<String, Int>? = null
  public val table: Map<String, Int>
    get() {
        if (_table == null) {
            _table = HashMap() // Type parameters are inferred
        }
        return _table ?: throw AssertionError("Set to null by another thread")
    }
  ```

#### Compile Time Constant
- If the value of a read-only property is known at compile time, mark it as a compile time constant using the 'const' modifier.
- In order to make property as a compile time constant, property needs to fulfill following requirements.
  - It must be a top-level property, or a member of an `object declaration` or a `companion object`.
  - It must be initialized with a value of type String or a primitive type.
  - It cannot have a custom getter (and, since it’s a constant, it naturally can’t have a setter either)
  ```
  const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"

  @Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { ... }
  ```

#### Late-initialized properties
- `lateinit` means late initialization. If you do not want to initialize a variable in the constructor instead you want to initialize it later on and if you can guarantee the initialization before using it, then declare that variable with `lateinit` keyword.
- This modifier can be used on non null `var` properties declared inside the body of a class.
- You cannot use val for `lateinit` variable as it will be initialized later on.
- It can also be used if the property does not have custom setter or getter.
- It can't be used in the class constructor.
- It can't be used with primative data type. As primative data type has it's default value.
- Accessing a `lateinit` property before it has been initialized throws a special exception that clearly identifies the property being accessed and the fact that it hasn't been initialized.
- In order to avoid this exception, the `lateinit` property must be initialize before using and you can also check if the `lateinnit` property has been initialized or not by using `.isInitialized` on the reference to that property.