## Extensions

- Kotlin provides the ability to add a new functionality into a class or an interface without having to inherit from the class.
- It allows to add new functionality to existing classes without updating or changing inside that classes.
- For example, you can write new functions for a class or an interface from a third-party library that you can't modify. Such functions can be called in the usual way, as if they were methods of the original class. This mechanism is called an extension function. There are also extension properties that let you define new properties for existing classes.

### Extension Functions 
- To define an extension function, add the name of that function after the class (a class where you want to add new function).
- The `this` keyword inside the extension function refer to that class.
- The object can use that extension function, if it matches with the class type. Example, if we add an extension function using String class, an String type object can use that function.
- It's perfectly fine for extension function to overload member function with same name but different signature.
- Extensions can be defined with a nullable receiver type. These extensions can be called on an object variable even if its value is null.
- Example:
```
fun MutableList<Int>.swap(index1: Int, index2: Int) {
	val tmp = this[index1] // 'this' corresponds to the list 
	this[index1] = this[index2] 
	this[index2] = tmp 
}

fun main() {
	val list = mutableListOf(1, 2, 3) 
	list.swap(0, 2)
}

//

fun String.removeFirstAndLastChar(): String {
	return this.substring(1, this.length - 1) 
} 

fun main() { 
	val myString = "Hello" 
	val result = myString.removeFirstAndLastChar()
	println(result)  // Output: "ell" 
}
```