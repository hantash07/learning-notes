### Ways to Perform Background Tasks and Their Restrictions
#### 1. Threads & Handlers
- It runs tasks on a background thread separately from the UI thread.
- Useful for simple, short-lived tasks like image processing or file reading.
- Simple, lightweight
- Restrictions: 
	- If the app is killed, the thread is killed too.
	- Not lifecycle-aware
	- No guarantee of execution when the app is in the background.
	- Should **not** be used for long-running or scheduled tasks.

#### 2. Executors / ThreadPoolExecutor
- It is used to run parallel or multiple background tasks separately from the UI thread.
- Useful for multiple tasks.
- Restrictions: 
	- If the app is killed, the thread is killed too.
	- Not lifecycle-aware
	- No guarantee of execution when the app is in the background.
	- Should **not** be used for long-running or scheduled tasks.

#### 3. AsyncTask (Deprecated)
- Used for simple background tasks tied to the Activity lifecycle.
- Restrictions: 
	- Deprecated since Android 11.
	- Memory leaks & lifecycle issues.
	- Not reliable for background work.

#### 4. Kotlin Coroutines
- Modern way to handle background tasks with structured concurrency.
- This is useful if you want to tie the task to the UI lifecycle.
- Clean, lifecycle-aware.
- Restrictions: 
	- Not for guaranteed long-running background tasks. If the app is killed, the process is killed too.
	- Should **not** be used for long-running or scheduled tasks.

#### 5. Background Services
**a) Started Service**
- Runs in the background indefinitely until stopped.
- Restrictions:
	- From Android 8.0+, **apps can’t run background services freely** → services are killed when the app goes to the background.
	- Should use **WorkManager** or **Foreground Service** instead.

#### 6. Foreground Service
- It runs long-running tasks. The user is aware of the task execution.
- Restrictions:
	- Requires a **notification** to be shown.
	- In Android 12: must call `startForeground()` within 10s of starting.
	- Background-start restrictions: can't freely start services when the app is in the background (post Oreo). In short, this service only starts when the app is in the foreground state.

#### 7. JobScheduler
- It schedules jobs with conditions (network available, charging, idle).
- Restrictions:
	- Minimum API 21 (Lollipop).
	- Jobs are **batched** → no guarantee of exact timing.
	- No built-in support for **chained jobs** (job → job → job)
	- Not suitable for immediate work.

#### 8. AlarmManager
- Schedule tasks at specific times.
- Useful for Alarms, reminders, and notifications.
- Restrictions:
	- Before Android 6.0 (Marshmallow), if you set an alarm with `AlarmManager.setExact()` or `setRepeating()`, it fired **at the exact time** you specified.
	- After Android 6.0, when the phone is **idle (No Activity on the Phone)**, Normal alarms (`set()`, `setRepeating()`, even `setExact()`) are **delayed**.
	- If you want to still run an alarm during idle mode, use `setExactAndAllowWhileIdle()`. But if abused, Android kills your alarms.
	- No guarantee of execution when the app is idle.

#### 9. BroadcastReceiver
- Trigger background work on system or app events (boot complete, connectivity change).
- Useful for responding to events (e.g., sync when Wi-Fi is connected).
- Restrictions:
	- After Android 8.0 (Oreo), apps are no longer allowed to register implicit broadcasts in the manifest file that apps do not know. Example: CONNECTIVITY_CHANGE 
	- Instead, you must use **dynamic registration** (inside code with `registerReceiver()`) or use **JobScheduler/WorkManager**.
	- The following are the allowed implicit broadcasts that still can be registered in the manifest: BOOT_COMPLETED, SMS_RECEIVED, PACKAGE_ADDED, PACKAGE_REMOVED, PACKAGE_REPLACED, TIMEZONE_CHANGED, LOCALE_CHANGED, and a few other broadcasts that apps _must_ know about.
	- After Android 8.0 (Oreo), if your app is in the **background**, you **cannot** start a normal background `Service` directly from a `BroadcastReceiver`.
	- `BroadcastReceiver.onReceive()` must finish **quickly**. 
	- Don’t do network requests or database sync directly inside `onReceive()`, as it is a long task and the system may kill the app.

#### 10. WorkManager
- Schedule guaranteed jobs with conditions (network available, charging, idle).
- Useful for reliable background work that must survive app restarts (syncing, uploading logs).
- Restrictions:
	- Uses **JobScheduler** (API 23+) or **AlarmManager + BroadcastReceiver** (below API 23).
	- Minimum periodic interval = **15 minutes**.
	- Not for exact timing tasks.