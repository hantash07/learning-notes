The lifecycle of WorkManager can be understood in two layers:
#### 1. WorkManager Lifecycle (The System)
- How WorkManager itself survives across app restarts.
#### 2. Worker Lifecycle
- How workers execute the work request.

### WorkManager Lifecycle (The System)
- WorkManager is initialized
- All enqueued works are stored in an SQLite database (`workdb`).
- If the app is killed or the device restarts, the pending works are restored with the help of the `workdb`.
- WorkManager internally decides whether to use `JobScheduler` or `AlarmManager` + `BroadcastReceiver`.

### Worker Lifecycle
```
        ENQUEUED
            │
            ▼
         BLOCKED (if dependencies exist)
            │
            ▼
         RUNNING
       /    |    \
      ▼     ▼     ▼
 SUCCEEDED RETRY FAILED
             │
             ▼
        ENQUEUED (again)

```

- ENQUEUED
	- Work is created and stored in the DB.
	- Waiting for **constraints** to be met (network, charging, idle, etc.).
	- If chained → waits until dependencies finish.
- BLOCKED
	- Work is dependent on another unfinished work.
	- Example: `WorkB` depends on `WorkA`. Until `WorkA` finishes → `WorkB` = BLOCKED.
- RUNNING
	- WorkManager schedules the job → Worker’s `doWork()` is called.
	- If constraints are lost mid-execution (e.g., network drops) → execution is stopped, and work goes back to ENQUEUED.
- SUCCEEDED
	- `doWork()` returns `Result.success()`.
	- Work is marked as finished.
	- Any dependent work is unblocked and enqueued.
	- Output `Data` is passed to the next work in the chain.
- RETRY
	- `doWork()` returns `Result.retry()`.
	- Work goes back to ENQUEUED with a **backoff policy** (linear or exponential).
	- Retries continue until success/failure or quota is exceeded.
- FAILED
	- `doWork()` returns `Result.failure()`.
	- Work stops permanently.
	- Dependent works are **not run**.
- CANCELLED
	- Work can be explicitly cancelled using:
		- cancelWorkById()
		- cancelUniqueWork()
		- or automatically replaced via `ExistingWorkPolicy.REPLACE`
	- When cancelled, work stops immediately.
#### Special Case: **Periodic Work Lifecycle**
- Periodic work never truly finishes.
- If `Result.success()` → it is rescheduled for the next interval.
- If `Result.retry()` → retried before next interval.
- If `Result.failure()` → it stops forever (does not repeat).
- Can only be cancelled explicitly.
