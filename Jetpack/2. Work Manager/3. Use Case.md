### Why WorkManager Exists
- Android has had multiple APIs for background work:
	- **Services** → Run tasks in the background (but heavy, killed under Doze).
	- **AlarmManager** → Schedule tasks, but not guaranteed if the device is idle.
	- **JobScheduler** → Works from API 21+, but you still need backward compatibility.
- WorkManager **abstracts all these APIs** and guarantees that work will **eventually run**, no matter:
	- The app is killed
	- Device restarts
	- OS restrictions (Doze, battery optimizations)
- WorkManager decides internally whether to use:
	- `JobScheduler` (preferred, API 23+)
	- `AlarmManager + BroadcastReceiver` (API < 23)
	- `Firebase JobDispatcher` (legacy, no longer required)

### How It Works Inside WorkManager
The reason why WorkManager is **guaranteed** → because of the following persistence layer:
- Work is stored in an **internal SQLite DB**.
- Worker states & constraints are tracked persistently.
- If app/device restarts → SQLite DB reloads → resumes pending work.
- Uses OS schedulers:
	- JobScheduler (preferred)
	- AlarmManager + BroadcastReceiver (fallback)

# **WorkManager vs Foreground Service vs AlarmManager?**